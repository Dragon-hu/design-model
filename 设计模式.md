## 设计模式

### 一、面向对象的六原则一法则

开闭原则、里氏替换原则、依赖倒置原则、单一职责原则、接口隔离原则、合成复用原则、迪米特法则

#### 1、开闭原则

> 面对扩展开放、面对修改关闭。

开闭原则是面向对象程序设计的终极目标，它使软件实体拥有一定的适应性和灵活性的同时具备稳定性和延续性。

#### 2、里氏替换原则

里氏替换原则的主要作用如下。

1. **里氏替换原则是实现开闭原则的重要方式之一。**
2. 它克服了继承中重写父类造成的可复用性变差的缺点。
3. 它是动作正确性的保证。即类的扩展不会给已有的系统引入新的错误，降低了代码出错的可能性。

里氏替换原则通俗来讲就是：子类可以扩展父类的功能，但不能改变父类原有的功能。也就是说：**子类继承父类时，除添加新的方法完成新增功能外，尽量不要重写父类的方法。**

#### 3、依赖倒置原则

**依赖倒置原则是实现开闭原则的重要途径之一**，它降低了客户与实现模块之间的耦合。

依赖倒置原则的目的是通过要**面向接口的编程**来降低类间的耦合性，所以我们在实际编程中只要遵循以下4点，就能在项目中满足这个规则。

1. 每个类尽量提供接口或抽象类，或者两者都具备。
2. 变量的声明类型尽量是接口或者是抽象类。
3. 任何类都不应该从具体类派生。
4. 使用继承时尽量遵循里氏替换原则。

#### 4、单一职责原则

该原则提出对象不应该承担太多职责

#### 5、接口隔离原则

接口隔离原则（Interface Segregation Principle，ISP）要求程序员尽量将臃肿庞大的接口拆分成更小的和更具体的接口，让接口中只包含客户感兴趣的方法。

接口隔离原则和单一职责都是为了**提高类的内聚性、降低它们之间的耦合性**，体现了封装的思想，但两者是不同的：

- 单一职责原则注重的是职责，而接口隔离原则注重的是对接口依赖的隔离。
- 单一职责原则主要是约束类，它针对的是程序中的实现和细节；接口隔离原则主要约束接口，主要针对抽象和程序整体框架的构建。

#### 6、合成复用原则

合成复用原则（Composite Reuse Principle，CRP）又叫组合/聚合复用原则（Composition/Aggregate Reuse Principle，CARP）。它要求在软件复用时，要尽量先使用**组合或者聚合**等关联关系来实现，其次才考虑使用继承关系来实现。

#### 7、迪米特法则

迪米特法则（Law of Demeter，LoD）又叫作最少知识原则（Least Knowledge Principle，LKP)，一个类对其他类有尽可能少的了解。

迪米特法则要求限制软件实体之间通信的宽度和深度，正确使用迪米特法则将有以下两个优点。

1. 降低了类之间的耦合度，提高了模块的相对独立性。
2. 由于亲合度降低，从而提高了类的可复用率和系统的扩展性。

### 二、创建型模式

创建型模式的主要关注点是怎样创建对象，它的主要特点是“将对象的创建与使用分离”。这样可以降低系统的耦合度，使用者不需要关注对象的创建细节，对象的创建由相关的工厂来完成。

创建型模式分为以下几种。

- 单例（Singleton）模式：某个类只能生成一个实例，该类提供了一个全局访问点供外部获取该实例，其拓展是有限多例模式。
- 原型（Prototype）模式：将一个对象作为原型，通过对其进行复制而克隆出多个和原型类似的新实例。
- 工厂方法（FactoryMethod）模式：定义一个用于创建产品的接口，由子类决定生产什么产品。
- 抽象工厂（AbstractFactory）模式：提供一个创建产品族的接口，其每个子类可以生产一系列相关的产品。
- 建造者（Builder）模式：将一个复杂对象分解成多个相对简单的部分，然后根据不同需要分别创建它们，最后构建成该复杂对象

以上 5 种创建型模式，除了工厂方法模式属于**类创建型模式**，其他的全部属于**对象创建型模式。**

#### 1、单例模式

单例（Singleton）模式的定义：指一个类只有一个实例，且该类能自行创建这个实例的一种模式。

单例模式有 3 个特点：

1. 单例类只有一个实例对象；
2. 该单例对象必须由单例类自行创建；
3. 单例类对外提供一个访问该单例的全局访问点；

应用场景：

- 在应用场景中，某类只要求生成一个对象的时候，如一个班中的班长、每个人的身份证号等。
- 当对象需要被共享的场合。由于单例模式只允许创建一个对象，共享该对象可以节省内存，并加快对象访问速度。如 Web 中的配置对象、数据库的连接池等。
- 当某类需要频繁实例化，而创建的对象又频繁被销毁的时候，如多线程的线程池、网络连接池等。

实现方式：

##### 1.1 饿汉式

```java
package com.qianfeng.singleton;

/**
 * 饿汉式单例，类加载的时候就创建实例对象
 * @author huwen
 */
public class HungrySingleton {
    /**
     * 创建一个静态实例
     */
    private static HungrySingleton instance = new HungrySingleton();

    /**
     * 私有化构造方法
     */
    private HungrySingleton(){}

    /**
     * 提供外界访问的方法
     * @return 返回之前创建的实例
     */
    public static HungrySingleton getInstance(){
        return instance;
    }
}
```

饿汉式类加载的时候就创建实例对象，比较消耗内存，但是是线程安全的。

##### 1.2 懒汉式(双重校验锁)

```java
package com.qianfeng.singleton;

/**
 * 懒汉式(双重校验锁，线程安全)
 * @author huwen
 */
public class LazySingleton {
    /**
     * 静态变量，加上volatile防止指令重排
     */
    private volatile static LazySingleton instance = null;

    private LazySingleton() {
    }

    /**
     * 静态方法，供外界访问的接口
     * @return
     */
    public static LazySingleton getInstance(){
        //首先判断是否为null，如果不为null，说明已经创建了，不用锁了
        if(instance==null){
            //同步代码块，多个线程同时只能有一个线程执行同步代码块中的代码
            synchronized (LazySingleton.class){
                //需要再次判断是否为null
                if(instance==null){
                    instance = new LazySingleton();
                }
            }
        }
        return instance;
    }
}
```

使用双重校验锁的懒汉式只有当第一次调用静态方法`getInstance()`的时候才会创建实例对象，之后每次调用都不会创建对象了，并且是线程安全的。

##### 1.3 静态内部类

```java
package com.qianfeng.singleton;

/**
 * 静态内部类的单例模式
 * @author huwen
 */
public class StaticInnerSingleton {
    private StaticInnerSingleton(){};

    /**
     * 一个静态内部类
     */
    private static class SingletonHolder{
        //创建一个静态常量的实例对象
        private static final StaticInnerSingleton INSTANCE = new StaticInnerSingleton();
    }
    public static StaticInnerSingleton getInstance(){
        return SingletonHolder.INSTANCE;
    }
}
```

第一次加载外部类的时候并不会创建实例对象，只有当第一次调用`getInstance()`方法时才会创建实例对象，线程安全，推荐使用。

##### 1.4 枚举

```java
package com.qianfeng.singleton;

/**
 * 枚举单例
 */
public enum EnumSingleton {
    INSTANCE;
    public void doSomething(){}
}
```

枚举单例的可读性不强，大部分应用开发很少使用枚举，所以不推荐使用。

#### 2、原型模式

原型（Prototype）模式的定义如下：用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。用这种方式创建对象非常高效，根本无须知道对象创建的细节。

原型模式包含以下主要角色。

1. 抽象原型类：规定了具体原型对象必须实现的接口。
2. 具体原型类：实现抽象原型类的 clone() 方法，它是可被复制的对象。
3. 访问类：使用具体原型类中的 clone() 方法来复制新的对象。

> 浅拷贝与深拷贝的区别：
>
> 两者的区别在于对引用数据类型(除了String类型)的拷贝，浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象。

```java
package com.qianfeng.prototype;

/**
 * @author huwen
 */
public class Realizetype implements Cloneable {
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
	/**
	*重写clone()方法
	*/
    @Override
    protected Object clone() throws CloneNotSupportedException {
        Realizetype realizetype = (Realizetype) super.clone();;

        return realizetype;
    }
}
```

PrototypeTest.java

```java
package com.qianfeng.prototype;

import org.junit.Test;

public class PrototypeTest {
    @Test
    public void testPrototype(){
        Realizetype realizetype = new Realizetype();
        realizetype.setName("张三");
        System.out.println(realizetype.getName());
        try {
            Object obj = realizetype.clone();
            Realizetype realizetype1 = (Realizetype)obj;
            System.out.println(realizetype1.getName());
        } catch (CloneNotSupportedException e) {
            e.printStackTrace();
        }
    }
}
```

clone的时候先创建一个对象，然后调用它的clone()方法，这里实现的是浅拷贝，也是默认的方式，如果想要实现深拷贝，需要在clone方法中重新创建一个成员变量。

原型模式通常适用于以下场景。

- 对象之间相同或相似，即只是个别的几个属性不同的时候。
- 对象的创建过程比较麻烦，但复制比较简单的时候。

#### 3、工厂方法模式

工厂方法（FactoryMethod）模式的定义：定义一个创建产品对象的工厂接口，将产品对象的实际创建工作推迟到具体子工厂类当中。这满足创建型模式中所要求的“创建与使用相分离”的特点。

我们把被创建的对象称为“产品”，把创建产品的对象称为“工厂”。如果要创建的产品不多，只要一个工厂类就可以完成，这种模式叫“简单工厂模式”，它不属于 GoF 的 23 种经典设计模式，它的缺点是增加新产品时会违背“开闭原则”。

##### 3.1 简单工厂模式

简单工厂模式属于创建型模式又叫做**静态工厂方法模式**，它属于类创建型模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。 **简单工厂模式专门定义一个类来负责创建其他类的实例，被创建的实例通常都具有共同的父类。**

简单工厂模式有三个角色：

* Factory：工厂类，简单工厂模式的核心，它负责实现创建所有实例的内部逻辑。工厂类的创建产品类的方法可以被外界直接调用，创建所需的产品对象。

* AbstractProduct：抽象产品类，简单工厂模式所创建的所有对象的父类，它负责描述所有实例所共有的公共接口。

* Product：具体产品类，是简单工厂模式的创建目标。

现在假设我们要根据传入的不同类型的参数创建不同品牌的电脑：

AbstractComputer.java

```java
package com.qianfeng.simplefactory;

/**
 * @author huwen
 */
public abstract class AbstractComputer {
    /**
     * 产品的抽象方法，由具体的产品类去实现
     */
    public abstract void start();
}
```

这个类是抽象产品类，负责描述所有产品都具有的接口。

```java
package com.qianfeng.simplefactory;

/**
 * @author huwen
 */
public class LenovoComputer extends AbstractComputer {
    @Override
    public void start() {
        System.out.println("联想电脑启动了");
    }
}
```

这个类是联想电脑类。

```java
package com.qianfeng.simplefactory;

public class DellComputer extends AbstractComputer {
    @Override
    public void start() {
        System.out.println("戴尔电脑启动了");
    }
}
```

```java
package com.qianfeng.simplefactory;

public class HpComputer extends AbstractComputer {
    @Override
    public void start() {
        System.out.println("惠普电脑启动了");
    }
}
```

测试类：

```java
package com.qianfeng.simplefactory;

import org.junit.Test;

public class SimpleFactoryTest {
    @Test
    public void testLenovo(){
        AbstractComputer computer = ComputerFactory.createComputer("lenovo");
        computer.start();
    }
    @Test
    public void testDell(){
        AbstractComputer computer = ComputerFactory.createComputer("dell");
        computer.start();
    }
    @Test
    public void testHp(){
        AbstractComputer computer = ComputerFactory.createComputer("hp");
        computer.start();
    }
}
```

优点和缺点

优点

- 工厂类含有必要的判断逻辑，可以决定在什么时候创建哪一个产品类的实例，客户端可以**免除直接创建产品对象的责任**，而仅仅“消费”产品；简单工厂模式通过这种做法**实现了对责任的分割**，它提供了**专门的工厂类用于创建对象**。
- 客户端无须知道所创建的具体产品类的类名，只需要知道具体产品类**所对应的参数**即可，对于一些复杂的类名，通过简单工厂模式可以减少使用者的记忆量。
- 通过引入配置文件，可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，在一定程度上提高了系统的灵活性。

缺点

- 由于**工厂类集中了所有产品创建逻辑**，一旦不能正常工作，整个系统都要受到影响。
- 使用简单工厂模式将会增加系统中类的个数，在一定程序上增加了系统的复杂度和理解难度。
- **系统扩展困难，一旦添加新产品就不得不修改工厂逻辑，同样破坏了“开闭原则”；在产品类型较多时，有可能造成工厂逻辑过于复杂，不利于系统的扩展和维护**。
- 简单工厂模式由于使用了静态工厂方法，造成工厂角色**无法形成基于继承的等级结构**。

##### 3.2 工厂方法模式

工厂方法模式的主要优点有：

- 用户只需要知道具体工厂的名称就可得到所要的产品，无须知道产品的具体创建过程；
- 在系统增加新的产品时只需要添加具体产品类和对应的具体工厂类，无须对原工厂进行任何修改，满足开闭原则；

其缺点是：每增加一个产品就要增加一个具体产品类和一个对应的具体工厂类，这增加了系统的复杂度。

工厂方法模式的主要角色如下。

1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，调用者通过它访问具体工厂的工厂方法 newProduct() 来创建产品。
2. 具体工厂（ConcreteFactory）：主要是实现抽象工厂中的抽象方法，完成具体产品的创建。
3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能。
4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它同具体工厂之间一一对应。

和简单工厂模式相比，多个抽象工厂类和具体工厂类：

```java
package com.qianfeng.factorymethod;

public abstract class AbstractFactory {
    public abstract AbstractComputer createComputer();
}
```

抽象工厂类，规定了具体工厂类必须要重写的方法。

```java
package com.qianfeng.factorymethod;

public class LenovoFactory extends AbstractFactory {
    @Override
    public AbstractComputer createComputer() {
        return new LenovoComputer();
    }
}
```

测试类：

```java
package com.qianfeng.factorymethod;

import org.junit.Test;

public class FactoryMethodTest {
    @Test
    public void testFactoryMethod(){
        AbstractFactory abstractFactory1 = new LenovoFactory();
        abstractFactory1.createComputer().start();
        AbstractFactory abstractFactory2 = new DellFactory();
        abstractFactory2.createComputer().start();
        AbstractFactory abstractFactory3 = new HpFactory();
        abstractFactory3.createComputer().start();
    }
}
```

优点：

- 更符合开-闭原则 
  新增一种产品时，只需要增加相应的具体产品类和相应的工厂子类即可

  > 简单工厂模式需要修改工厂类的判断逻辑

- 符合单一职责原则 
  每个具体工厂类只负责创建对应的产品

  > 简单工厂中的工厂类存在复杂的switch逻辑判断

- 不使用静态工厂方法，可以形成基于继承的等级结构。

  > 简单工厂模式的工厂类使用静态工厂方法

总结：工厂模式可以说是简单工厂模式的进一步抽象和拓展，在保留了简单工厂的封装优点的同时，让扩展变得简单，让继承变得可行，增加了多态性的体现。

缺点：

- 添加新产品时，除了增加新产品类外，还要提供与之对应的具体工厂类，系统类的个数将成对增加，在一定程度上增加了系统的复杂度；同时，有更多的类需要编译和运行，会给系统带来一些额外的开销；
- 由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。
- 虽然保证了工厂方法内的对修改关闭，但对于使用工厂方法的类，如果要更换另外一种产品，仍然需要修改实例化的具体工厂类；
- 一个具体工厂只能创建一种具体产品

应用场景：

- 当一个类不知道它所需要的对象的类时 
  在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可；
- 当一个类希望通过其子类来指定创建对象时 
  在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。
- 将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。

#### 4、抽象工厂模式

前面介绍的工厂方法模式中考虑的是一类产品的生产，如畜牧场只养动物、电视机厂只生产电视机、计算机软件学院只培养计算机软件专业的学生等。

同种类称为同等级，也就是说：工厂方法模式只考虑生产同等级的产品，但是在现实生活中许多工厂是综合型的工厂，能生产多等级（种类） 的产品，如农场里既养动物又种植物，电器厂既生产电视机又生产洗衣机或空调，大学既有软件专业又有生物专业等。

将同一个具体工厂所生产的位于不同等级的一组产品称为一个产品族，如下表所示

| 产品等级 | 电脑     | 手机     |
| -------- | -------- | -------- |
| 产品族   |          |          |
| 华为     | 华为电脑 | 华为手机 |
| 小米     | 小米电脑 | 小米手机 |

抽象工厂（AbstractFactory）模式的定义：是一种为访问类提供一个创建一组相关或相互依赖对象的接口，且访问类无须指定所要产品的具体类就能得到同族的不同等级的产品的模式结构。抽象工厂模式是工厂方法模式的升级版本，**工厂方法模式只生产一个等级的产品，而抽象工厂模式可生产多个等级的产品。**

抽象工厂模式的主要角色如下。

1. 抽象工厂（Abstract Factory）：提供了创建产品的接口，它包含多个创建产品的方法 newProduct()，可以创建多个不同等级的产品。
2. 具体工厂（Concrete Factory）：主要是实现抽象工厂中的多个抽象方法，完成具体产品的创建。
3. 抽象产品（Product）：定义了产品的规范，描述了产品的主要特性和功能，抽象工厂模式有多个抽象产品。
4. 具体产品（ConcreteProduct）：实现了抽象产品角色所定义的接口，由具体工厂来创建，它 同具体工厂之间是多对一的关系。

使用抽象工厂模式一般要满足以下条件。

- 系统中有多个产品族，每个具体工厂创建同一族但属于不同等级结构的产品。
- 系统一次只可能消费其中某一族产品，即同族的产品一起使用。


抽象工厂模式除了具有工厂方法模式的优点外，其他主要优点如下。

- 可以在类的内部对产品族中相关联的多等级产品共同管理，而不必专门引入多个新的类来进行管理。
- 当增加一个新的产品族时不需要修改原代码，满足开闭原则。

其缺点是：当产品族中需要增加一个新的产品时，所有的工厂类都需要进行修改。

**电脑接口**：抽象产品类

```java
package com.qianfeng.abstractfactory;

public interface Computer {
    void show();
}
```

**电视接口**：抽象产品类

```java
package com.qianfeng.abstractfactory;

public interface Television {
    void show();
}
```

**小米电脑**：具体产品类

```java
package com.qianfeng.abstractfactory;

public class XiaomiComputer implements Computer {
    @Override
    public void show() {
        System.out.println("小米电视创建了");
    }
}
```

**小米电视**：具体产品类

```java
package com.qianfeng.abstractfactory;

public class XiaomiTelevision implements Television {
    @Override
    public void show() {
        System.out.println("小米电视创建了");
    }
}
```

**华为电脑**：具体产品类

```java
package com.qianfeng.abstractfactory;

public class HuaweiComputer implements Computer {
    @Override
    public void show() {
        System.out.println("华为电视创建了");
    }
}
```

**华为电视**：具体产品类

```java
package com.qianfeng.abstractfactory;

public class HuaweiTelevision implements Television {
    @Override
    public void show() {
        System.out.println("华为电视创建了");
    }
}
```

**抽象工厂类**：

```java
package com.qianfeng.abstractfactory;

public abstract class AbstractFactory {
    public abstract Computer createComputer();
    public abstract Television createTelevision();
}
```

**小米工厂：具体工厂类**

```java
package com.qianfeng.abstractfactory;

public class XiaomiFactory extends AbstractFactory {
    @Override
    public Computer createComputer() {
        return new XiaomiComputer();
    }

    @Override
    public Television createTelevision() {
        return new XiaomiTelevision();
    }
}
```

**华为工厂：具体工厂类**

```java
package com.qianfeng.abstractfactory;

public class HuaweiFactory extends AbstractFactory {
    @Override
    public Computer createComputer() {
        return new HuaweiComputer();
    }

    @Override
    public Television createTelevision() {
        return new HuaweiTelevision();
    }
}
```

测试类：

```java
package com.qianfeng.abstracfactory;

import com.qianfeng.abstractfactory.AbstractFactory;
import com.qianfeng.abstractfactory.HuaweiFactory;
import com.qianfeng.abstractfactory.XiaomiFactory;
import org.junit.Test;

public class AbstractFactoryTest {
    @Test
    public void testAbstractFactory(){
        AbstractFactory xiaomiFactory = new XiaomiFactory();
        xiaomiFactory.createComputer().show();
        xiaomiFactory.createTelevision().show();
        AbstractFactory huaweiFactory = new HuaweiFactory();
        huaweiFactory.createTelevision().show();
        huaweiFactory.createComputer().show();
    }
}
```

#### 5、建造者模式

##### 5.1 定义

建造者（Builder）模式的定义：指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示，这样的设计模式被称为建造者模式。它是将一个复杂的对象分解为多个简单的对象，然后一步一步构建而成。它将变与不变相分离，即产品的组成部分是不变的，但每一部分是可以灵活选择的。

##### 5.2 优缺点

该模式的主要优点如下：

1. 各个具体的建造者相互独立，有利于系统的扩展。
2. 客户端不必知道产品内部组成的细节，便于控制细节风险。


其缺点如下：

1. 产品的组成部分必须相同，这限制了其使用范围。
2. 如果产品的内部变化复杂，该模式会增加很多的建造者类。

建造者（Builder）模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程，但两者可以结合使用。

##### 5.3 适用场景

* 隔离复杂对象的创建和使用，相同的方法，不同执行顺序，产生不同事件结果

* 多个部件都可以装配到一个对象中，但产生的运行结果不相同

* 产品类非常复杂或者产品类因为调用顺序不同而产生不同作用

* 初始化一个对象时，参数过多，或者很多参数具有默认值

* Builder模式不适合创建差异性很大的产品类
   产品内部变化复杂，会导致需要定义很多具体建造者类实现变化，增加项目中类的数量，增加系统的理解难度和运行成本

* 需要生成的产品对象有复杂的内部结构，这些产品对象具备共性

##### 5.4 角色讲解

* 指挥者（Director）直接和客户（Client）进行需求沟通；

* 沟通后指挥者将客户创建产品的需求划分为各个部件的建造请求（Builder）；

* 将各个部件的建造请求委派到具体的建造者（ConcreteBuilder）；

* 各个具体建造者负责进行产品部件的构建；

* 最终构建成具体产品（Product）。

##### 5.5 代码展示

Product.java

```java
package com.qianfeng.builder;

public class Product {
    private String partA;
    private String partB;
    private String partC;

    public String getPartA() {
        return partA;
    }

    public void setPartA(String partA) {
        this.partA = partA;
    }

    public String getPartB() {
        return partB;
    }

    public void setPartB(String partB) {
        this.partB = partB;
    }

    public String getPartC() {
        return partC;
    }

    public void setPartC(String partC) {
        this.partC = partC;
    }

    public void show(){
        System.out.println("product被创建了");
    }
}
```

产品类，最终要被创建的产品

AbstractBuilder.java

```java
package com.qianfeng.builder;

public abstract class AbstractBuilder {
    protected  Product product = new Product();
    public abstract void buildPartA();
    public abstract void buildPartB();
    public abstract void buildPartC();
    public  Product getProduct(){
        return product;
    }
}
```

抽象建造者，规定了创建产品的方法。

```java
package com.qianfeng.builder;

public class ConcretBuilder extends AbstractBuilder {
    @Override
    public void buildPartA() {
        product.setPartA("建造partA");
    }

    @Override
    public void buildPartB() {
        product.setPartB("建造partB");
    }

    @Override
    public void buildPartC() {
        product.setPartC("建造partC");
    }
}
```

具体工厂类，重写创建产品的方法，执行创建产品的代码。

```java
package com.qianfeng.builder;

public class Director {
    private AbstractBuilder builder;
    public Director(AbstractBuilder builder){
        this.builder = builder;
    }
    public Product construct(){
        builder.buildPartA();
        builder.buildPartB();
        builder.buildPartC();
        return builder.getProduct();
    }
}
```

指挥者类，负责调用具体建造者执行创建产品的操作，最后返回创建好的产品

```java
package com.qianfeng.builder;

import org.junit.Test;

public class BuilderTest {
    @Test
    public void testBuilder(){
        AbstractBuilder builder = new ConcretBuilder();
        Director director = new Director(builder);
        Product product = director.construct();
        product.show();
    }
}
```

在测试类中，先创建具体建造者，然后传入具体建造者对象创建指挥者，通过指挥者的construct方法获得product对象，和传统的直接通过new关键字创建对象相比，我们不需要知道需要的参数。

##### 5.6 延伸与扩展

Computer.java

```java
package com.qianfeng.builder;

public class Computer {
    private String cpu;
    private String screen;
    private String memory;
    private String mainboard;

    public Computer(Builder builder){
        cpu = builder.cpu;
        screen = builder.screen;
        memory = builder.memory;
        mainboard = builder.mainboard;
    }

    public static final class Builder{
        private String cpu;
        private String screen;
        private String memory;
        private String mainboard;

        public Builder(){};

        public Builder screen(String val){
            screen = val;
            return this;
        }

        public Builder memory(String val){
            memory = val;
            return this;
        }

        public Builder cpu(String val){
            cpu = val;
            return this;
        }

        public Builder mainboard(String val){
            mainboard = val;
            return this;
        }

        public Computer build(){
            return new Computer(this);
        }
    }

    public void show(){
        System.out.println("cpu:"+cpu+";screen:"+screen+";memory:"+memory+";mainboard:"+mainboard);
    }
}
```

使用静态内部类的方式创建对象

```java
package com.qianfeng.builder;

import org.junit.Test;

public class BuilderTest {
    @Test
    public void testBuilder(){
        AbstractBuilder builder = new ConcretBuilder();
        Director director = new Director(builder);
        Product product = director.construct();
        product.show();
    }
    @Test
    public void testComputer(){
        Computer computer = new Computer.Builder()
                .cpu("i9-9900k")
                .screen("dell xasx6z7s")
                .memory("samsung 3200 16g")
                .mainboard("asus b360")
                .build();
        computer.show();
    }
}
```

上面的示例代码只是传入四个参数，如果参数是十四个甚至更多，builder 模式的优势将会更加明显，传递参数更加灵活，代码具有更高的可读性。

### 三、结构型模式

结构型模式描述如何将类或对象按某种布局组成更大的结构。它分为**类结构型模式**和**对象结构型模式**，前者采用**继承机制**来组织接口和类，后者釆用**组合或聚合**来组合对象。由于组合关系或聚合关系比继承关系耦合度低，满足“合成复用原则”，所以**对象结构型模式比类结构型模式具有更大的灵活性**。

结构型模式分为以下 7 种：

1. 代理（Proxy）模式：为某对象提供一种代理以控制对该对象的访问。即客户端通过代理间接地访问该对象，从而限制、增强或修改该对象的一些特性。
2. 适配器（Adapter）模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。
3. 桥接（Bridge）模式：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。
4. 装饰（Decorator）模式：动态地给对象增加一些职责，即增加其额外的功能。
5. 外观（Facade）模式：为多个复杂的子系统提供一个一致的接口，使这些子系统更加容易被访问。
6. 享元（Flyweight）模式：运用共享技术来有效地支持大量细粒度对象的复用。
7. 组合（Composite）模式：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。

以上 7 种结构型模式，除了**适配器模式**分为类结构型模式和对象结构型模式两种，其他的全部属于对象结构型模式。

#### 1、代理模式

##### 1.1 定义及优缺点

代理模式的定义：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

代理模式的主要优点有：

- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；
- 代理对象可以扩展目标对象的功能；
- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度；


其主要缺点是：

- 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢；
- 增加了系统的复杂度；

##### 1.2 分类

 我们有多种不同的方式来实现代理。如果按照代理创建的时期来进行分类的话， 可以分为两种：静态代理、动态代理。静态代理是由程序员创建或特定工具自动生成源代码，在对其编译。在程序员运行之前，代理类.class文件就已经被创建了。动态代理是在程序运行时通过反射机制动态创建的。动态代理又可以分为jdk自带的动态代理以及cglib提供的动态代理。

##### 1.3 静态代理

接口

```java
package com.qianfeng.proxy.staticproxy;

public interface Subject {
    void request();
}
```

接口中定义了需要实现的方法

```java
package com.qianfeng.proxy.staticproxy;

public class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("调用真实主题的request方法");
    }
}
```

这个是实现类，实现了接口中的方法

```java
package com.qianfeng.proxy.staticproxy;

public class Proxy implements Subject {
    private RealSubject realSubject;
    @Override
    public void request() {
        if(realSubject==null){
            realSubject = new RealSubject();
        }
        before();
        realSubject.request();
        after();
    }

    public void before(){
        System.out.println("-------before-----------");
    }

    public void after(){
        System.out.println("--------after------------");
    }
}
```

这个是代理类，同样需要实现接口，定义了一个被代理类的对象，当调用代理类的request方法时，会调用被代理类的request方法，并在调用被代理类的方法的前后分别调用了自定义的before和after方法。

```java
package com.qianfeng.proxy.staticproxy;

import org.junit.Test;

public class ProxyTest {
    @Test
    public void testProxy(){
        Proxy proxy = new Proxy();
        proxy.request();
    }
}
```

测试类中只需要创建代理类的对象并调用方法就可以帮我们调用对应被代理类的对象，还可以在不修改源代码的基础上增加功能。

##### 1.4 动态代理之jdk动态代理

jdk自带的动态代理使用了动态生成字节码技术，在运行期间而不是编译期间进行代理，所以又称为动态代理。jdk自带的动态代理需要被代理类实现一个或多个接口。

```java
package com.qianfeng.proxy.jdkdynamicproxy;

public interface Subject {
    void request();
}
```

```java
package com.qianfeng.proxy.jdkdynamicproxy;

public class RealSubject implements Subject {
    @Override
    public void request() {
        System.out.println("调用真实主题的request方法");
    }
}
```

这两个类与之前的静态代理方式相同，无需过多解释。

```java
package com.qianfeng.proxy.jdkdynamicproxy;

public class MyAspect {
    public void before(){
        System.out.println("-------before-----------");
    }

    public void after(){
        System.out.println("--------after------------");
    }
}
```

想要在运行期间执行的方法放在这个类中，和前一种方式相比，降低了代码之间的耦合，不再需要在这个类中实现接口并重写方法了。

```java
package com.qianfeng.proxy.jdkdynamicproxy;

import java.lang.reflect.InvocationHandler;
import java.lang.reflect.Method;
import java.lang.reflect.Proxy;

public class DynamicHandler {
    public static Subject getSubject(){
        Subject subject = new RealSubject();
        MyAspect myAspect = new MyAspect();
        Subject s1 = (Subject) Proxy.newProxyInstance(DynamicHandler.class.getClassLoader(), subject.getClass().getInterfaces(), new InvocationHandler() {
            @Override
            public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
                myAspect.before();
                Object obj = method.invoke(subject, args);
                myAspect.after();
                return obj;
            }
        });
        return s1;
    }
}
```

最重要的是这个类，这个类中的静态方法用于返回代理实例。首先创建了被代理类以及想要执行额外的方法的类的对象，然后调用Proxy类中的静态方法newProxyInstance()返回代理类。这个方法的参数有三个：第一个是目标类加载器，第二个参数是目标类的所有接口，第三个参数是一个实现了InvocationHandler接口的类的对象。指定动态处理器，执行目标对象的方法时,会触发事件处理器的方法。重写的invoke方法中的第一个参数是代理实例，也就是我们想要返回的代理对象，第二个方法是目标类的方法，第三个参数是方法中的参数。`method.invoke(subject, args);`就是在执行目标类的方法，可以在方法的前后分别执行想要添加的代码。最后把代理实例返回就行了。这样就实现了动态代理。

```java
package com.qianfeng.proxy.jdkdynamicproxy;

import org.junit.Test;

public class TestJDKProxy {
    @Test
    public void tessJDK(){
        Subject subject = DynamicHandler.getSubject();
        subject.request();
    }
}
```

jdk自带的动态代理，目标类必须实现一个或多个接口。

##### 1.5 cglib动态代理

cglib的动态代理不需要目标类实现接口，基于更为底层的字节码生成技术，继承目标类，然后重写方法。

```java
package com.qianfeng.proxy.cglib;

public class RealSubject{

    public void request() {
        System.out.println("调用真实主题的request方法");
    }
}
```

由于不需要实现接口，所以上面的目标类代码看起来更为清爽

```java
package com.qianfeng.proxy.cglib;

public class MyAspect {
    public void before(){
        System.out.println("-------before-----------");
    }

    public void after(){
        System.out.println("--------after------------");
    }
}
```

```java
package com.qianfeng.proxy.cglib;


import net.sf.cglib.proxy.Enhancer;
import net.sf.cglib.proxy.MethodInterceptor;
import net.sf.cglib.proxy.MethodProxy;

import java.lang.reflect.Method;

public class DynamicHandler {
    public static RealSubject getSubject(){
        Enhancer enhancer = new Enhancer();
        enhancer.setSuperclass(RealSubject.class);
        MyAspect myAspect = new MyAspect();
        RealSubject realSubject = new RealSubject();
        enhancer.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                myAspect.before();
                Object obj = method.invoke(realSubject, objects);
                myAspect.after();
                return obj;
            }
        });
        RealSubject subject = (RealSubject) enhancer.create();
        return subject;
    }
}
```

这个类中的静态方法用于生成代理对象，intercept()方法几乎和上面的invoke()方法一模一样，只是多了一个MethodProxy参数。

```java
package com.qianfeng.proxy.cglib;

import org.junit.Test;

public class TestCglib {
    @Test
    public void testCglib(){
        RealSubject subject = DynamicHandler.getSubject();
        subject.request();
    }
}
```

测试类还是一样的简单。

#### 2、适配器模式

##### 2.1 简介与定义

大家在日常生活中经常使用电源适配器吧，比如对于电脑来说，电脑需要的电压和电流与电网中提供的电压和电流不一致，如果电脑直接连接电网，电脑中的元器件就可能损坏，为了解决这种电压和电流不一致的情况，就出现了适配器。

适配器模式（Adapter）的定义如下：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。**适配器模式分为类结构型模式和对象结构型模式两种，前者类之间的耦合度比后者高，且要求程序员了解现有组件库中的相关组件的内部结构，所以应用相对较少些。**

该模式的主要优点如下。

- 客户端通过适配器可以透明地调用目标接口。
- 复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。
- 将目标类和适配者类解耦，解决了目标类和适配者类接口不一致的问题。


其缺点是：对类适配器来说，更换适配器的实现过程比较复杂。

##### 2.2 分类

根据适配器类与适配者类的关系不同，适配器模式可分为**对象适配器**和**类适配器**两种，在**对象适配器模式**中，适配器与适配者之间是**关联**关系；在**类适配器模式**中，适配器与适配者之间是**继承**（或实现）关系。

##### 2.3 角色

* Target（目标抽象类）：目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。

* Adapter（适配器类）：适配器可以调用另一个接口，作为一个转换器，对Adaptee和Target进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承Target并关联一个Adaptee对象使二者产生联系。

* Adaptee（适配者类）：适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。

##### 2.4 类适配器模式

适配者类：

```java
package com.qianfeng.adapter.classadapter;

/**
 * 适配者类定义了将要在目标接口中被调用的方法
 */
public class Adaptee {
    public void specificRequest(){
        System.out.println("适配者中的业务代码被调用");
    }
}
```

目标接口：

```java
package com.qianfeng.adapter.classadapter;

/**
 * 目标接口
 */
public interface Target {
    void request();
}
```

类适配器：

```java
package com.qianfeng.adapter.classadapter;

/**
 * 类适配器 同时继承适配者，实现目标接口
 */
public class ClassAdapter extends Adaptee implements Target {
    @Override
    public void request() {
        specificRequest();
    }
}
```

类适配器通过继承适配者类、实现目标接口，能够在一个接口方法中调用父类的方法，这样就实现了按目标接口的格式访问适配者。

##### 2.5 对象适配器模式

对象适配器类

```java
package com.qianfeng.adapter.objectadapter;

public class ObjectAdapter implements Target {
    private Adaptee adaptee;

    public ObjectAdapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void request() {
        adaptee.specificRequest();
    }
}
```

对象适配器类只实现了目标接口并重写了方法，和类适配器模式不同的是，定义了一个适配者的成员变量，然后内部调用这个成员变量的方法进行适配。

```java
package com.qianfeng.adapter.objectadapter;

import org.junit.Test;

public class ObjectAdapterTest {
    @Test
    public void testObjectAdapter(){
        Adaptee adaptee = new Adaptee();
        Target target = new ObjectAdapter(adaptee);
        target.request();
    }
}
```

客户端调用的时候先创建适配者对象，然后传入对象适配器的构造方法中创建一个对象适配器，调用内部的方法就可以了。

#### 3、桥接模式

##### 3.1 定义

桥接（Bridge）模式的定义如下：将抽象与实现分离，使它们可以独立变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

桥接（Bridge）模式的优点是：

- 由于抽象与实现分离，所以扩展能力强；
- 其实现细节对客户透明。


缺点是：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，这增加了系统的理解与设计难度。

举例：比如说我现在需要提供大中小3种型号的画笔，能够绘制3种不同颜色，如果使用蜡笔，我们需要准备3*3=9支蜡笔，也就是说必须准备9个具体的蜡笔类。而如果使用毛笔的话，只需要3种型号的毛笔，外加3个颜料盒，用3+3=6个类就可以实现9支蜡笔的功能。

##### 3.2 结构与角色

可以将抽象化部分与实现化部分分开，取消二者的继承关系，改用组合关系。

桥接（Bridge）模式包含以下主要角色。

1. 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用。
2. 扩展抽象化（Refined  Abstraction）角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
3. 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用。
4. 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现。

在接下来的例子中，抽象化角色相当于毛笔这个类，扩展抽象化角色则是大中小三种型号的毛笔，实现化角色则是颜色，具体实现化角色比如红色、绿色、黄色等。

##### 3.2 示例

抽象化角色，在此例中相当于毛笔类

```java
package com.qianfeng.bridge;

public abstract class Abstraction {
    protected Implementor implementor;
    protected Abstraction(Implementor implementor){
        this.implementor = implementor;
    }

    public abstract void operation();
}
```

扩展抽象化角色，在此例中相当于不同型号的毛笔

```java
package com.qianfeng.bridge;

public class RedefinedAbstraction extends Abstraction {
    protected RedefinedAbstraction(Implementor implementor) {
        super(implementor);
    }

    @Override
    public void operation() {
        System.out.println("扩展抽象化角色被访问");
        implementor.operationImpl();
    }
}
```

实现化角色，在此例中相当于颜色这个接口

```java
package com.qianfeng.bridge;

public interface Implementor {
    void operationImpl();
}
```

具体实现化角色，在此例中相当于不同的颜色(红、黄、绿)等。

```java
package com.qianfeng.bridge;

public class ConcreteImplementor implements Implementor {
    @Override
    public void operationImpl() {
        System.out.println("具体实现化角色被访问");
    }
}
```

测试类：通过调用扩展抽象化角色的方法实现不同的功能

```java
package com.qianfeng.bridge;

import org.junit.Test;

public class BridgeTest {
    @Test
    public void testBridge(){
        Implementor implementor = new ConcreteImplementor();
        Abstraction abstraction = new RedefinedAbstraction(implementor);
        abstraction.operation();
    }
}
```

#### 4、装饰模式

##### 4.1 定义

装饰（Decorator）模式的定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些职责（即增加其额外功能）的模式，它属于对象结构型模式。

装饰（Decorator）模式的主要优点有：

- 采用装饰模式扩展对象的功能比采用继承方式更加灵活。
- 可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。


其主要缺点是：装饰模式增加了许多子类，如果过度使用会使程序变得很复杂。

##### 4.2  结构与角色

通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。下面来分析其基本结构和实现方法。

装饰模式主要包含以下角色。

1. 抽象构件（Component）角色：定义一个抽象接口以规范准备接收附加责任的对象。
2. 具体构件（Concrete  Component）角色：实现抽象构件，通过装饰角色为其添加一些职责。
3. 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。
4. 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。

##### 4.3 代码实现

抽象构件角色，将要被实现的接口

```java
package com.qianfeng.decorator;

/**
 * 抽象构件角色
 * @author huwen
 */
public interface Component {
    /**
     * 规范实现类必须重写的方法，也是需要调用的方法
     */
    void operation();
}
```

具体构件角色：

```Java
package com.qianfeng.decorator;

/**
 * @author huwen
 */
public class ConcreteComponent implements Component {
    public ConcreteComponent(){
        System.out.println("创建具体构件角色");
    }
    @Override
    public void operation() {
        System.out.println("调用具体构件角色的方法operation()");
    }
}
```

抽象装饰器角色，实现了构件接口，同时还有一个构件对象，在operation方法中调用了构件对象的operation方法。

```java
package com.qianfeng.decorator;


public class Decorator implements Component {
    private Component component;

    public Decorator(Component component) {
        this.component = component;
    }

    @Override
    public void operation() {
        component.operation();
    }
}
```

具体装饰器角色A：

```java
package com.qianfeng.decorator;

/**
 * 具体装饰器角色
 * @author huwen
 */
public class ConcreteDecoratorA extends Decorator {
    public ConcreteDecoratorA(Component component) {
        //初始化父类对象，设置属性component
        super(component);
    }

    @Override
    public void operation(){
        //调用父类的operation方法
        //实质上就是调用了具体构件的operation方法
        super.operation();
        addedFunction();
    }

    /**
     * 增加功能
     */
    public void addedFunction(){
        System.out.println("为具体构件角色增加额外的功能addedFunctionA()");
    }
}
```

具体装饰器角色B：

```java
package com.qianfeng.decorator;

/**
 * 具体装饰器角色
 * @author huwen
 */
public class ConcreteDecoratorB extends Decorator {
    public ConcreteDecoratorB(Component component) {
        //初始化父类对象，设置属性component
        super(component);
    }

    @Override
    public void operation(){
        //调用父类的operation方法
        //实质上就是调用了具体构件的operation方法
        super.operation();
        addedFunction();
    }

    /**
     * 增加功能
     */
    public void addedFunction(){
        System.out.println("为具体构件角色增加额外的功能addedFunctionB()");
    }
}
```

测试类：在测试类中先创建了一个具体构件对象，然后使用这个具体构件对象创建了一个具体装饰器对象A，最后使用了创建好的具体装饰器对象A创建了一个

```java
package com.qianfeng.decorator;

import org.junit.Test;

public class DecoratorTest {
    @Test
    public void testDecorator(){
        ConcreteComponent component = new ConcreteComponent();
        ConcreteDecoratorA decoratorA = new ConcreteDecoratorA(component);
        ConcreteDecoratorB decoratorB = new ConcreteDecoratorB(decoratorA);

        decoratorB.operation();
    }
}
```

打印结果：

```tex
创建具体构件角色
调用具体构件角色的方法operation()
为具体构件角色增加额外的功能addedFunctionA()
为具体构件角色增加额外的功能addedFunctionB()

```

> 有时候可能并不存在这个抽象构件角色，这是可以让抽象装饰器角色继承具体构件角色；有时候我们只需要一个具体装饰器角色，这时候抽象装饰器角色就和具体装饰器角色合二为一了。

#### 5、外观模式

##### 5.1 定义及优缺点

外观（Facade）模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体的细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。

外观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。

1. 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
2. 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
3. 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。


外观（Facade）模式的主要缺点如下。

1. 不能很好地限制客户使用子系统类。
2. 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。

##### 5.2 结构与角色

外观（Facade）模式的结构比较简单，主要是定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。

外观（Facade）模式包含以下主要角色。

1. 外观（Facade）角色：为多个子系统对外提供一个共同的接口。
2. 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
3. 客户（Client）角色：通过一个外观角色访问各个子系统的功能。

##### 5.3 代码实现

子系统A

```java
package com.qianfeng.facade;

/**
 * @author huwen
 */
public class SubSystemA {
    public void show(){
        System.out.println("调用子系统A");
    }
}
```

子系统B

```java
package com.qianfeng.facade;

/**
 * @author huwen
 */
public class SubSystemB {
    public void show(){
        System.out.println("调用子系统B");
    }
}
```

子系统C

```java
package com.qianfeng.facade;

/**
 * @author huwen
 */
public class SubSystemC {
    public void show(){
        System.out.println("调用子系统C");
    }
}
```

外观类：

```java
package com.qianfeng.facade;

public class Facade {
    private SubSystemA systemA;
    private SubSystemB systemB;
    private SubSystemC systemC;

    public Facade() {
        this.systemA = new SubSystemA();
        this.systemB = new SubSystemB();
        this.systemC = new SubSystemC();
    }

    public void showA(){
        systemA.show();
    }

    public void showB(){
        systemB.show();
    }

    public void showC(){
        systemC.show();
    }
}
```

测试类：

```java
package com.qianfeng.facade;

import org.junit.Test;

public class FacadeTest {
    @Test
    public void testFacade(){
        Facade facade = new Facade();
        facade.showA();
        facade.showB();
        facade.showC();
    }
}
```

外观模式采用了聚合关系来代替继承关系，实现了松耦合，如果有新的子系统加进来的时候只需要在外观类中增加一个新的类的成员变量就行了。

#### 6、享元模式

##### 6.1 定义与特点

说到享元模式，第一个想到的应该就是池技术了，String常量池、数据库连接池、缓冲池等等都是享元模式的应用，所以说**享元模式是池技术的重要实现方式。**

享元（Flyweight）模式的定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。

享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。

其主要缺点是：

1. 为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。
2. 读取享元模式的外部状态会使得运行时间稍微变长。

##### 6.2 结构与实现

享元模式中存在以下两种状态：

1. **内部状态**，即不会随着环境的改变而改变的可共享部分；
2. **外部状态**，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，**并将外部状态外部化**。下面来分析其基本结构和实现方法。

享元模式的主要角色有如下。

1. 抽象享元角色（Flyweight）:是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。
2. 具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。
3. 不共享的享元（Unsharable Flyweight)角色：有时候不需要共享
4. 享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。

##### 6.3 代码实现

抽象享元角色

```java
package com.qianfeng.flyweight;

public interface Flyweight {
    void operation(int extrinsicstate);
}
```

具体享元角色：

```java
package com.qianfeng.flyweight;

public class ConcreteFlyweight implements Flyweight {

    @Override
    public void operation(int extrinsicstate) {
        System.out.println("共享的享元角色："+extrinsicstate);
    }
}
```

非共享的享元角色：

```java
package com.qianfeng.flyweight;

public class UnsharedConcreteFlyweight implements Flyweight {

    @Override
    public void operation(int extrinsicstate) {
        System.out.println("不共享的具体享元角色："+extrinsicstate);
    }
}
```

享元工厂

```java
package com.qianfeng.flyweight;

import java.util.HashMap;
import java.util.Map;

public class FlyweightFactory {
    private Map<String,Flyweight> flyweights = new HashMap<>();

    public FlyweightFactory() {
        flyweights.put("a",new ConcreteFlyweight());
        flyweights.put("b",new ConcreteFlyweight());
        flyweights.put("c",new ConcreteFlyweight());
    }

    public Flyweight getFlyweight(String key){
        Flyweight flyweight = flyweights.get(key);
        if(flyweight!=null){
            System.out.println("具体享元 "+key+" 已经存在，被成功获取！");
        } else {
            flyweight = new ConcreteFlyweight();
            flyweights.put(key,flyweight);
        }
        return flyweight;
    }
}
```

测试类：

```java
package com.qianfeng.flyweight;

import org.junit.Test;

public class FlyweightTest {
    @Test
    public void testFlyWeight(){
        int extrinsicstate = 22;
        FlyweightFactory factory = new FlyweightFactory();
        Flyweight a = factory.getFlyweight("a");
        a.operation(--extrinsicstate);
        Flyweight b = factory.getFlyweight("b");
        b.operation(--extrinsicstate);
        Flyweight d = factory.getFlyweight("d");
        d.operation(--extrinsicstate);
        UnsharedConcreteFlyweight uf = new UnsharedConcreteFlyweight();
        uf.operation(--extrinsicstate);
    }
}
```

#### 7、组合模式

##### 7.1 定义

组合（Composite）模式的定义：有时又叫作部分-整体模式，它是一种将对象组合成**树状的层次结构**的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。

组合模式的主要优点有：

1. 组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，这简化了客户端代码；
2. 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”；


其主要缺点是：

1. 设计较复杂，客户端需要花更多时间理清类之间的层次关系；
2. 不容易限制容器中的构件；
3. 不容易用继承的方法来增加构件的新功能；

##### 7.2 结构和角色

组合模式包含以下主要角色。

1. 抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。
2. 树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中 声明的公共接口。
3. 树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含 Add()、Remove()、GetChild() 等方法。

组合模式有两种方式的实现，一种是透明方式，另一种是安全方式。透明方式中，尽管叶子节点不可能再长出新节点，但是为了保持外界访问的一致性，具备完全一致的行为接口，同时实现add()与remove()方法也是没有意义的。安全模式中，再Component接口中不再声明add()与remove()方法，子类的Leaf节点就不需要去实现，只在Composite中声明所有用来管理子类对象的方法，但是这种方式不够透明，所以树叶和树枝将不再具有相同的接口，客户端的调用需要做相应的判断，带来了不便。

##### 7.3 代码实现

抽象接口

```java
package com.qianfeng.composite;

/**
 * Component为组合中的对象声明接口
 */
public abstract class Component {
    protected String name;

    public Component(String name) {
        this.name = name;
    }

    /**
     * 增加树叶或树枝
     * @param c 树叶或树枝对象
     */
    public abstract void add(Component c);

    /**
     * 移除树叶或树枝
     * @param c 将要移除的树叶或树枝对象
     */
    public abstract void remove(Component c);
    public abstract void display(int depth);
}
```

树枝节点：

```java
package com.qianfeng.composite;

import java.util.ArrayList;
import java.util.List;

/**
 * 定义树枝节点的行为，用来存储子部件
 */
public class Composite extends Component {
    /**
     * 当前树枝节点的所有子节点，有可能是树枝节点，也有可能是树叶节点
     */
    private List<Component> children  = new ArrayList<>();
    public Composite(String name) {
        super(name);
    }

    /**
     * 增加子节点
     * @param c 树叶或树枝对象
     */
    @Override
    public void add(Component c) {
        children.add(c);
    }

    /**
     * 移除当前树叶节点的某个子节点
     * @param c 将要移除的树叶或树枝对象
     */
    @Override
    public void remove(Component c) {
        children.remove(c);
    }

    /**
     * 显示节点名称，并对子节点进行遍历
     * @param depth
     */
    @Override
    public void display(int depth) {
        for (int i = 0; i < depth ; i++) {
            System.out.print("-");
        }
        System.out.println(name);
        for (Component child : children) {
            child.display(depth+2);
        }
    }
}
```

树叶节点：

```java
package com.qianfeng.composite;

/**
 * Leaf在组合中表示叶节点对象，叶节点没有子节点
 */
public class Leaf extends Component {
    public Leaf(String name) {
        super(name);
    }

    /**
     * 由于叶节点不能增加树枝或树叶，所以add和remove方法没有实现的意义
     * 但这样做可以消除叶子节点和树枝节点对象在抽象层次的区别，
     * 它们具备完全一致的接口
     * @param c 树叶或树枝对象
     */
    @Override
    public void add(Component c) {
        System.out.println("cannot add to a leaf");
    }

    @Override
    public void remove(Component c) {
        System.out.println("cannot remove from a leaf");
    }

    @Override
    public void display(int depth) {
        for (int i = 0; i < depth ; i++) {
            System.out.print("-");
        }
        System.out.println(name);
    }
}
```

测试类：

```java
package com.qianfeng.composite;

import org.junit.Test;

public class CompositeTest {
    @Test
    public void compositeTest(){
        Composite root = new Composite("root");
        //根上长出两个叶节点
        root.add(new Leaf("Leaf A"));
        root.add(new Leaf("Leaf B"));

        Composite comp = new Composite("Composite X");
        //composite X树枝节点上长出两个叶节点
        comp.add(new Leaf("Leaf XA"));
        comp.add(new Leaf("Leaf XB"));

        //把composite X挂在根上
        root.add(comp);

        Composite comp2 = new Composite("Composite XY");
        //composite X树枝节点上长出两个叶节点
        comp2.add(new Leaf("Leaf XYA"));
        comp2.add(new Leaf("Leaf XYB"));

        comp.add(comp2);

        root.add(new Leaf("Leaf C"));
        Leaf leaf = new Leaf("Leaf D");
        root.add(leaf);
        root.remove(leaf);

        root.display(1);
    }
}
```

### 四、行为型模式

行为型模式用于描述程序在运行时复杂的流程控制，即描述多个类或对象之间怎样相互协作共同完成单个对象都无法单独完成的任务，它涉及算法与对象间职责的分配。

行为型模式分为**类行为模式**和**对象行为模式**，前者采用**继承机制**来在类间分派行为，后者采用**组合或聚合**在对象间分配行为。由于组合关系或聚合关系比继承关系耦合度低，满足“**合成复用原则**”，所以**对象行为模式比类行为模式具有更大的灵活性**。

行为型模式是 GoF 设计模式中最为庞大的一类，它包含以下 11 种模式。

1. 模板方法（Template Method）模式：定义一个操作中的算法骨架，将算法的一些步骤延迟到子类中，使得子类在可以不改变该算法结构的情况下重定义该算法的某些特定步骤。
2. 策略（Strategy）模式：定义了一系列算法，并将每个算法封装起来，使它们可以相互替换，且算法的改变不会影响使用算法的客户。
3. 命令（Command）模式：将一个请求封装为一个对象，使发出请求的责任和执行请求的责任分割开。
4. 职责链（Chain of Responsibility）模式：把请求从链中的一个对象传到下一个对象，直到请求被响应为止。通过这种方式去除对象之间的耦合。
5. 状态（State）模式：允许一个对象在其内部状态发生改变时改变其行为能力。
6. 观察者（Observer）模式：多个对象间存在一对多关系，当一个对象发生改变时，把这种改变通知给其他多个对象，从而影响其他对象的行为。
7. 中介者（Mediator）模式：定义一个中介对象来简化原有对象之间的交互关系，降低系统中对象间的耦合度，使原有对象之间不必相互了解。
8. 迭代器（Iterator）模式：提供一种方法来顺序访问聚合对象中的一系列数据，而不暴露聚合对象的内部表示。
9. 访问者（Visitor）模式：在不改变集合元素的前提下，为一个集合中的每个元素提供多种访问方式，即每个元素有多个访问者对象访问。
10. 备忘录（Memento）模式：在不破坏封装性的前提下，获取并保存一个对象的内部状态，以便以后恢复它。
11. 解释器（Interpreter）模式：提供如何定义语言的文法，以及对语言句子的解释方法，即解释器。

以上 11 种行为型模式，除了**模板方法模式和解释器模式**是类行为型模式，其他的全部属于对象行为型模式，

#### 1、模板方法模式

在面向对象程序设计过程中，程序员常常会遇到这种情况：设计一个系统时知道了算法所需的**关键步骤**，而且确定了这些步骤的**执行顺序**，但某些步骤的**具体实现还未知，或者说某些步骤的实现与具体的环境相关。**

例如，去银行办理业务一般要经过以下4个流程：取号、排队、办理具体业务、对银行工作人员进行评分等，其中取号、排队和对银行工作人员进行评分的业务对每个客户是一样的，可以在父类中实现，但是办理具体业务却因人而异，它可能是存款、取款或者转账等，**可以延迟到子类中实现。**

这样的例子在生活中还有很多，例如，一个人每天会起床、吃饭、做事、睡觉等，其中“做事”的内容每天可能不同。我们把这些规定了流程或格式的实例定义成模板，允许使用者根据自己的需求去更新它，例如，简历模板、论文模板、Word 中模板文件等。

##### 1.1 定义和特点

模板方法（Template Method）模式的定义如下：定义一个操作中的**算法骨架**，而将算法的一些步骤**延迟到子类**中，使得子类可以不改变该算法结构的情况下重定义该算法的某些特定步骤。它是一种类行为型模式。

该模式的主要优点如下。

1. 它封装了不变部分，扩展可变部分。它把认为是不变部分的算法封装到父类中实现，而把可变部分算法由子类继承实现，便于子类继续扩展。
2. 它在父类中提取了公共的部分代码，便于代码复用。
3. 部分方法是由子类实现的，因此子类可以通过扩展方式增加相应的功能，符合开闭原则。


该模式的主要缺点如下。

1. 对每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象。
2. 父类中的抽象方法由子类实现，子类执行的结果会影响父类的结果，这导致一种反向的控制结构，它提高了代码阅读的难度。

##### 1.2 结构和角色

模板方法模式包含以下主要角色。

(1) 抽象类（Abstract Class）：负责给出一个算法的轮廓和骨架。它由一个模板方法和若干个基本方法构成。这些方法的定义如下。

① 模板方法：定义了算法的骨架，按某种顺序调用其包含的基本方法。

② 基本方法：是整个算法中的一个步骤，包含以下几种类型。

- 抽象方法：在抽象类中申明，由具体子类实现。
- 具体方法：在抽象类中已经实现，在具体子类中可以继承或重写它。
- 钩子方法：在抽象类中已经实现，包括用于判断的逻辑方法和需要子类重写的空方法两种。


(2) 具体子类（Concrete Class）：实现抽象类中所定义的抽象方法和钩子方法，它们是一个顶级逻辑的一个组成步骤。

##### 1.3 代码实现

抽象模板类

抽象模板，定义并实现了一个模板方法，这个模板方法一般是一个具体方法，给出了一个顶级 逻辑的框架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现

```java
package com.qianfeng.template;

/**
 * 抽象模板，定义并实现了一个模板方法，这个模板方法一般是一个具体方法，给出了一个顶级
 * 逻辑的框架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现
 */
public abstract class AbstractClass {
    public abstract void primitiveOperation1();
    public abstract void primitiveOperation2();

    public void templateMethod(){
        primitiveOperation1();
        primitiveOperation2();
        System.out.println("");
    }
}
```

具体实现类：

具体实现类重写了每个步骤的实现

```java
package com.qianfeng.template;

/**
 * 实现父类所定义的一个或多个抽象方法，可以有多个具体类
 */
public class ConcreteClassA extends AbstractClass {
    @Override
    public void primitiveOperation1() {
        System.out.println("具体类A方法1实现");
    }

    @Override
    public void primitiveOperation2() {
        System.out.println("具体类A方法2实现");
    }
}
```

```java
package com.qianfeng.template;

/**
 * 实现父类所定义的一个或多个抽象方法，可以有多个具体类
 */
public class ConcreteClassB extends AbstractClass {
    @Override
    public void primitiveOperation1() {
        System.out.println("具体类B方法1实现");
    }

    @Override
    public void primitiveOperation2() {
        System.out.println("具体类B方法2实现");
    }
}
```

测试类：

```java
package com.qianfeng.template;

import org.junit.Test;

public class TemplateTest {
    @Test
    public void testTemplate(){
        AbstractClass c = null;

        c = new ConcreteClassA();
        c.templateMethod();

        c = new ConcreteClassB();
        c.templateMethod();
    }
}
```